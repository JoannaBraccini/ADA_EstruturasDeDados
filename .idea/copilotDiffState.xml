<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# EstruturasDeDados — Guia rápido para estudantes&#10;&#10;[![Ada — Elas + Tech](https://img.shields.io/badge/Ada-ELAS%20%2B%20TECH-purple?style=flat-square)](https://ada.tech) [![LinkedIn](https://img.shields.io/badge/LinkedIn-joannabraccini-blue?logo=linkedin&amp;style=flat-square)](https://www.linkedin.com/in/joannabraccini)&#10;&#10;**Nota:** Estas aulas fazem parte do programa *Ada — Elas + Tech*. Aqui estão exemplos simples de estruturas de dados em Java (listas, pilhas, filas, árvores etc.) pensados para estudo e prática. O repositório foi reorganizado como uma coleção de pastas de aula independentes; cada pasta de aula pode ter seu próprio `Main` quando necessário.&#10;&#10;---&#10;&#10;## Sumário&#10;- [Começar rápido](#come%C3%A7ar-r%C3%A1pido)&#10;- [O que tem neste repositório](#o-que-tem-neste-reposit%C3%B3rio)&#10;- [Descrição dos arquivos](#descri%C3%A7%C3%A3o-dos-arquivos)&#10;- [Verificação: ordem de inserção nas árvores](#verifica%C3%A7%C3%A3o-ordem-de-inser%C3%A7%C3%A3o-nas-%C3%A1rvores)&#10;- [Refatorações e melhorias sugeridas](#refatora%C3%A7%C3%B5es-e-melhorias-sugeridas)&#10;- [Complexidade — explicação rápida](#complexidade---explica%C3%A7%C3%A3o-r%C3%A1pida)&#10;- [Como usar — passos e exemplos](#como-usar---passos-e-exemplos)&#10;- [Contato](#contato)&#10;&#10;---&#10;&#10;## Começar rápido&#10;1. Abra um terminal na pasta do projeto.&#10;2. Compile o projeto (sem testes):&#10;&#10;```cmd&#10;mvn -DskipTests package&#10;```&#10;&#10;3. Rodar exemplos/samples: alguns subdiretórios possuem a própria classe `Main` para execução de exemplos (por exemplo `array_supermarket/main/Main.java`). Para executar uma classe `Main` específica após compilar, use o nome completo da classe ou execute a classe compilada a partir de `target/classes`.&#10;&#10;Exemplo (Windows/cmd.exe) — executar o `Main` em `array_supermarket.main`:&#10;&#10;```cmd&#10;java -cp target\classes array_supermarket.main.Main&#10;```&#10;&#10;Se uma pasta de aula não tem `Main`, você pode criar um pequeno `Main` local para testar a estrutura ou escrever testes unitários.&#10;&#10;---&#10;&#10;## O que tem neste repositório&#10;- `src/main/java/dataStructure` — implementações das estruturas (por ex. `LinkedList.java`, `Stack.java`, `Queue.java`, `Tree.java`, `BinarySearchTree.java`) com comentários e exemplos.&#10;- `src/main/java/array_supermarket` — exemplo didático de uma lista de compras implementada sobre um array fixo (`SupermarketArray`) com um `Main` para interação.&#10;- `src/main/java/FilaDeAtendimento.java` — exemplo independente que usa a `Queue` para simular atendimento ao cliente (pequena simulação/runner).&#10;&#10;---&#10;&#10;## Descrição dos arquivos&#10;Abaixo há uma descrição mais detalhada dos arquivos principais do repositório e qual conceito de aula eles ilustram. Use isto como mapa rápido para preparar aulas e exercícios.&#10;&#10;### `src/main/java/dataStructure/LinkedList.java`&#10;- O que é: Implementação de uma lista simplesmente encadeada (singly linked list) com operações básicas.&#10;- Conceitos demonstrados: nós (`Node`), referências (`next`), operações append/prepend, removeFirst/removeLast, get/insert/remove por índice, atualização (set), e menu interativo para testar as operações.&#10;- Conceito de aula: estrutura sequencial dinâmica; por que acesso aleatório é caro (O(n)) e por que inserções/remover no início são O(1).&#10;- Observação importante: o método `removeLast()` tem um caso-limite quando a lista tem exatamente 1 elemento que pode levar a comportamento incorreto. Veja sugestões de refatoração abaixo.&#10;&#10;### `src/main/java/dataStructure/Stack.java`&#10;- O que é: Pilha (Stack) implementada via nós encadeados.&#10;- Conceitos demonstrados: comportamento LIFO (Last-In, First-Out), operações `push` e `pop`, inspeção do topo (`getTop`) e altura (`getHeight`).&#10;- Conceito de aula: pilhas e usos (controle de chamadas, undo, avaliação de expressões).&#10;&#10;### `src/main/java/dataStructure/Queue.java`&#10;- O que é: Fila (Queue) implementada via nós encadeados.&#10;- Conceitos demonstrados: comportamento FIFO (First-In, First-Out), operações `enqueue` e `dequeue`, e impressão/inspeção dos elementos.&#10;- Conceito de aula: filas e aplicações (simulações, BFS, sistemas de atendimento). Usada por `FilaDeAtendimento.java`.&#10;&#10;### `src/main/java/dataStructure/Tree.java`&#10;- O que é: Árvore binária genérica (não ordenada) com inserção por nível (preenche a árvore da esquerda para a direita).&#10;- Conceitos demonstrados: definição de nó de árvore, inserção nível-a-nível usando uma fila auxiliar, percursos pré-ordem/in-ordem/pós-ordem, BFS (busca em largura) e noções de árvore cheia/completa/perfeita.&#10;- Conceito de aula: percursos de árvore e inserção por nível (útil para representar heaps e estruturas completas).&#10;- Observação: a ordem de inserção aqui segue preenchimento por nível; se você quiser que a árvore fique organizada como uma BST, use `BinarySearchTree` ou insira os valores em ordem que provoque a forma desejada.&#10;&#10;### `src/main/java/dataStructure/BinarySearchTree.java`&#10;- O que é: Árvore Binária de Busca (BST) com operações de `insert`, `contains`, `delete` e `inOrder`.&#10;- Conceitos demonstrados: propriedade BST (filhos à esquerda menores, à direita maiores), pesquisa eficiente (complexidade média O(log n)), remoção com os três casos (folha, um filho, dois filhos) e uso de `minValue` para substituir nós com dois filhos.&#10;- Conceito de aula: buscas ordenadas, remoção de nós em BST e travessias ordenadas (in-order produz ordenação crescente).&#10;- Verificação prática: o `main` nesta classe injeta os valores na ordem correta para produzir a árvore descrita na tarefa (raiz 37; 11 à esquerda; 66 à direita; 8 e 17 filhos de 11; 42 e 72 filhos de 66). Veja a seção abaixo sobre verificação.&#10;&#10;---&#10;&#10;## `src/main/java/array_supermarket`&#10;&#10;### `src/main/java/array_supermarket/implementation/Supermarket.java`&#10;- O que é: Interface que define a API mínima (contrato) de um supermercado/lista de compras (métodos `add`, `print`, `delete`).&#10;- Conceito de aula: interfaces, contratos e programação por abstração.&#10;&#10;### `src/main/java/array_supermarket/implementation/SupermarketArray.java`&#10;- O que é: Implementação da interface `Supermarket` usando um array fixo de tamanho definido no construtor.&#10;- Conceitos demonstrados: manipulação de arrays, controle de índice (`lastIndex`), verificação de overflow (lista cheia) e custo de operações (ex.: `delete` exige deslocamento de elementos — O(n)).&#10;- Conceito de aula: estruturas baseadas em arrays vs estruturas encadeadas; custo de deslocamento vs custo de alocação dinâmica.&#10;&#10;### `src/main/java/array_supermarket/main/Main.java`&#10;- O que é: Pequeno `Main` interativo que permite inserir, listar e remover itens da `SupermarketArray` via terminal.&#10;- Conceitos demonstrados: entrada/saída via `Scanner`, validação robusta de entrada (proteger EOF e entradas inválidas) e integração com a implementação concreta.&#10;&#10;---&#10;&#10;### `src/main/java/FilaDeAtendimento.java`&#10;- O que é: Runner independente que simula um sistema simples de atendimento ao cliente usando a classe `Queue` (gera números aleatórios para clientes e os atende em ordem FIFO).&#10;- Conceitos demonstrados: modelagem de filas no mundo real, uso de `Queue.enqueue` e `dequeue` até a fila ficar vazia.&#10;- Observação sobre localização: este arquivo está no pacote padrão (sem `package` declarado) e por isso fica no diretório raiz de `src/main/java/`. Arquivos no pacote padrão podem causar advertências/problemas em alguns IDEs e configurações de projeto.&#10;&#10;---&#10;&#10;## Verificação: ordem de inserção nas árvores&#10;Você fez a pergunta específica sobre uma árvore cuja raiz é 37, com filhos 11 (esq) e 66 (dir), filhos do 11 = 8 e 17, e do 66 = 42 e 72 — confirmei os `main` das duas classes de árvore:&#10;&#10;- `BinarySearchTree.main` insere na ordem: 37, 66, 42, 11, 72, 8, 17&#10;  - Resultado: essa ordem produz exatamente a árvore descrita quando as inserções seguem as regras da BST (menor à esquerda, maior à direita). Logo, `BinarySearchTree.main` está correto para esse layout.&#10;&#10;- `Tree.main` insere na ordem: 37, 11, 8, 17, 66, 42, 72&#10;  - Importante: `Tree` utiliza inserção por nível (preenche esquerda-&gt;direita usando uma fila). Com essa ordem o nó 66 não será filho direto da raiz — ele vai parar como filho do nó 11 (dependendo da sequência). Ou seja, `Tree` produz outra forma (estrutura por nível), não uma BST.&#10;&#10;Conclusão: se você quer aquela forma específica que respeita a propriedade BST, use `BinarySearchTree` (a `main` já insere em ordem correta). Se preferir que uma árvore genérica por nível tenha a mesma configuração, ajuste a ordem de inserção em `Tree.main` ou use o `BinarySearchTree` em sala.&#10;&#10;---&#10;&#10;## Refatorações e melhorias sugeridas (baixa complexidade de mudança)&#10;Pequenas melhorias que valem a pena e são ótimos exercícios para os estudantes:&#10;&#10;- Tornar as estruturas genéricas (usar generics: `LinkedList&lt;T&gt;`, `Stack&lt;T&gt;`, `Queue&lt;T&gt;`) para que suportem qualquer tipo, não só `int`/`String`.&#10;- BinarySearchTree.insert: renomear o parâmetro `root` do método recursivo para `node` para evitar confusão com o campo `root`. Outra opção: implementar versão iterativa para evitar overhead de recursão.&#10;- SupermarketArray.delete: atualmente o método espera índice 1-based (usuário vê), mas convém documentar isso no `Main` ou alterar para 0-based internamente. Também validar e retornar booleano em vez de apenas imprimir erro, para facilitar testes.&#10;- Adicionar testes unitários (JUnit) para cobrir casos de borda: listas vazias, remoção em listas com 1 elemento, remoção de nó com dois filhos em BST, etc.&#10;&#10;---&#10;&#10;## Complexidade — explicação rápida (Big-O) — para usar em aula&#10;- LinkedList (singly):&#10;  - append/prepend: O(1) (se temos ponteiro para tail para append)&#10;  - get(index): O(n)&#10;  - removeLast (se não há ponteiro para prev): O(n)&#10;- Stack (implementada com linked nodes):&#10;  - push/pop: O(1)&#10;  - acesso ao topo: O(1)&#10;- Queue (linked nodes):&#10;  - enqueue/dequeue: O(1)&#10;- BinarySearchTree (balanceada idealmente):&#10;  - search/insert/delete: O(log n) em média&#10;  - no pior caso (árvore degenerada): O(n)&#10;- Tree traversals (in/pre/post/BFS):&#10;  - todos os percursos visitam cada nó exatamente uma vez: O(n) tempo e O(h) espaço para recursão (h = altura)&#10;&#10;Dica pedagógica: enfatize diferença entre complexidade média e pior caso (BST depende da forma da árvore).&#10;&#10;---&#10;&#10;## Como usar — passos e exemplos&#10;Execute os `Main`s presentes nas pastas de exemplo, ou escreva pequenos runners/testes para experimentar as estruturas.&#10;&#10;### Exemplo rápido — executar `BinarySearchTree.main` compilado:&#10;&#10;```cmd&#10;mvn -DskipTests package&#10;java -cp target\classes dataStructure.BinarySearchTree&#10;```&#10;&#10;### Exemplo rápido — executar `array_supermarket`:&#10;&#10;```cmd&#10;mvn -DskipTests package&#10;java -cp target\classes array_supermarket.main.Main&#10;```&#10;&#10;---&#10;&#10;## Próximos passos sugeridos&#10;- Corrigir o `removeLast()` de `LinkedList` (pequena correção). Isso é um excelente exercício de revisão.&#10;- Converter as estruturas para `Generics` e adicionar testes JUnit rápidos.&#10;- Mover `FilaDeAtendimento` para um pacote (ex.: `app` ou `runner`) se quiser manter o projeto sem arquivos no pacote padrão.&#10;&#10;---&#10;&#10;## Contato&#10;Se quiser trocar ideias ou colaborar:&#10;&#10;- LinkedIn: https://www.linkedin.com/in/joannabraccini&#10;&#10;---&#10;&#10;(README atualizado em 2025-11-08)&#10;" />
              <option name="updatedContent" value="# EstruturasDeDados — Guia rápido para estudantes&#10;&#10;[![Ada — Elas + Tech](https://img.shields.io/badge/Ada-ELAS%20%2B%20TECH-purple?style=flat-square)](https://ada.tech) [![LinkedIn](https://img.shields.io/badge/LinkedIn-joannabraccini-blue?logo=linkedin&amp;style=flat-square)](https://www.linkedin.com/in/joannabraccini)&#10;&#10;**Nota:** Estas aulas fazem parte do programa *Ada — Elas + Tech*. Aqui estão exemplos simples de estruturas de dados em Java (listas, pilhas, filas, árvores etc.) pensados para estudo e prática. O repositório foi reorganizado como uma coleção de pastas de aula independentes; cada pasta de aula pode ter seu próprio `Main` quando necessário.&#10;&#10;---&#10;&#10;## Sumário&#10;- [Começar rápido](#come%C3%A7ar-r%C3%A1pido)&#10;- [O que tem neste repositório](#o-que-tem-neste-reposit%C3%B3rio)&#10;- [Descrição dos arquivos](#descri%C3%A7%C3%A3o-dos-arquivos)&#10;- [Verificação: ordem de inserção nas árvores](#verifica%C3%A7%C3%A3o-ordem-de-inser%C3%A7%C3%A3o-nas-%C3%A1rvores)&#10;- [Refatorações e melhorias sugeridas](#refatora%C3%A7%C3%B5es-e-melhorias-sugeridas)&#10;- [Complexidade — explicação rápida](#complexidade---explica%C3%A7%C3%A3o-r%C3%A1pida)&#10;- [Como usar — passos e exemplos](#como-usar---passos-e-exemplos)&#10;- [Contato](#contato)&#10;&#10;---&#10;&#10;## Começar rápido&#10;1. Abra um terminal na pasta do projeto.&#10;2. Compile o projeto (sem testes):&#10;&#10;```cmd&#10;mvn -DskipTests package&#10;```&#10;&#10;3. Rodar exemplos/samples: alguns subdiretórios possuem a própria classe `Main` para execução de exemplos (por exemplo `array_supermarket/main/Main.java`). Para executar uma classe `Main` específica após compilar, use o nome completo da classe ou execute a classe compilada a partir de `target/classes`.&#10;&#10;Exemplo (Windows/cmd.exe) — executar o `Main` em `array_supermarket.main`:&#10;&#10;```cmd&#10;java -cp target\classes array_supermarket.main.Main&#10;```&#10;&#10;Se uma pasta de aula não tem `Main`, você pode criar um pequeno `Main` local para testar a estrutura ou escrever testes unitários.&#10;&#10;---&#10;&#10;## O que tem neste repositório&#10;- `src/main/java/dataStructure` — implementações das estruturas (por ex. `LinkedList.java`, `Stack.java`, `Queue.java`, `Tree.java`, `BinarySearchTree.java`) com comentários e exemplos.&#10;- `src/main/java/array_supermarket` — exemplo didático de uma lista de compras implementada sobre um array fixo (`SupermarketArray`) com um `Main` para interação.&#10;- `src/main/java/FilaDeAtendimento.java` — exemplo independente que usa a `Queue` para simular atendimento ao cliente (pequena simulação/runner).&#10;&#10;---&#10;&#10;## Descrição dos arquivos&#10;Abaixo há uma descrição mais detalhada dos arquivos principais do repositório e qual conceito de aula eles ilustram. Use isto como mapa rápido para preparar aulas e exercícios.&#10;&#10;### `src/main/java/dataStructure/LinkedList.java`&#10;- O que é: Implementação de uma lista simplesmente encadeada (singly linked list) com operações básicas.&#10;- Conceitos demonstrados: nós (`Node`), referências (`next`), operações append/prepend, removeFirst/removeLast, get/insert/remove por índice, atualização (set), e menu interativo para testar as operações.&#10;- Conceito de aula: estrutura sequencial dinâmica; por que acesso aleatório é caro (O(n)) e por que inserções/remover no início são O(1).&#10;- Observação importante: o método `removeLast()` tem um caso-limite quando a lista tem exatamente 1 elemento que pode levar a comportamento incorreto. Veja sugestões de refatoração abaixo.&#10;&#10;### `src/main/java/dataStructure/Stack.java`&#10;- O que é: Pilha (Stack) implementada via nós encadeados.&#10;- Conceitos demonstrados: comportamento LIFO (Last-In, First-Out), operações `push` e `pop`, inspeção do topo (`getTop`) e altura (`getHeight`).&#10;- Conceito de aula: pilhas e usos (controle de chamadas, undo, avaliação de expressões).&#10;&#10;### `src/main/java/dataStructure/Queue.java`&#10;- O que é: Fila (Queue) implementada via nós encadeados.&#10;- Conceitos demonstrados: comportamento FIFO (First-In, First-Out), operações `enqueue` e `dequeue`, e impressão/inspeção dos elementos.&#10;- Conceito de aula: filas e aplicações (simulações, BFS, sistemas de atendimento). Usada por `FilaDeAtendimento.java`.&#10;&#10;### `src/main/java/dataStructure/Tree.java`&#10;- O que é: Árvore binária genérica (não ordenada) com inserção por nível (preenche a árvore da esquerda para a direita).&#10;- Conceitos demonstrados: definição de nó de árvore, inserção nível-a-nível usando uma fila auxiliar, percursos pré-ordem/in-ordem/pós-ordem, BFS (busca em largura) e noções de árvore cheia/completa/perfeita.&#10;- Conceito de aula: percursos de árvore e inserção por nível (útil para representar heaps e estruturas completas).&#10;- Observação: a ordem de inserção aqui segue preenchimento por nível; se você quiser que a árvore fique organizada como uma BST, use `BinarySearchTree` ou insira os valores em ordem que provoque a forma desejada.&#10;&#10;### `src/main/java/dataStructure/BinarySearchTree.java`&#10;- O que é: Árvore Binária de Busca (BST) com operações de `insert`, `contains`, `delete` e `inOrder`.&#10;- Conceitos demonstrados: propriedade BST (filhos à esquerda menores, à direita maiores), pesquisa eficiente (complexidade média O(log n)), remoção com os três casos (folha, um filho, dois filhos) e uso de `minValue` para substituir nós com dois filhos.&#10;- Conceito de aula: buscas ordenadas, remoção de nós em BST e travessias ordenadas (in-order produz ordenação crescente).&#10;- Verificação prática: o `main` nesta classe injeta os valores na ordem correta para produzir a árvore descrita na tarefa (raiz 37; 11 à esquerda; 66 à direita; 8 e 17 filhos de 11; 42 e 72 filhos de 66). Veja a seção abaixo sobre verificação.&#10;&#10;---&#10;&#10;## `src/main/java/array_supermarket`&#10;&#10;### `src/main/java/array_supermarket/implementation/Supermarket.java`&#10;- O que é: Interface que define a API mínima (contrato) de um supermercado/lista de compras (métodos `add`, `print`, `delete`).&#10;- Conceito de aula: interfaces, contratos e programação por abstração.&#10;&#10;### `src/main/java/array_supermarket/implementation/SupermarketArray.java`&#10;- O que é: Implementação da interface `Supermarket` usando um array fixo de tamanho definido no construtor.&#10;- Conceitos demonstrados: manipulação de arrays, controle de índice (`lastIndex`), verificação de overflow (lista cheia) e custo de operações (ex.: `delete` exige deslocamento de elementos — O(n)).&#10;- Conceito de aula: estruturas baseadas em arrays vs estruturas encadeadas; custo de deslocamento vs custo de alocação dinâmica.&#10;&#10;### `src/main/java/array_supermarket/main/Main.java`&#10;- O que é: Pequeno `Main` interativo que permite inserir, listar e remover itens da `SupermarketArray` via terminal.&#10;- Conceitos demonstrados: entrada/saída via `Scanner`, validação robusta de entrada (proteger EOF e entradas inválidas) e integração com a implementação concreta.&#10;&#10;---&#10;&#10;### `src/main/java/FilaDeAtendimento.java`&#10;- O que é: Runner independente que simula um sistema simples de atendimento ao cliente usando a classe `Queue` (gera números aleatórios para clientes e os atende em ordem FIFO).&#10;- Conceitos demonstrados: modelagem de filas no mundo real, uso de `Queue.enqueue` e `dequeue` até a fila ficar vazia.&#10;- Observação sobre localização: este arquivo está no pacote padrão (sem `package` declarado) e por isso fica no diretório raiz de `src/main/java/`. Arquivos no pacote padrão podem causar advertências/problemas em alguns IDEs e configurações de projeto.&#10;&#10;---&#10;&#10;## Verificação: ordem de inserção nas árvores&#10;Você fez a pergunta específica sobre uma árvore cuja raiz é 37, com filhos 11 (esq) e 66 (dir), filhos do 11 = 8 e 17, e do 66 = 42 e 72 — confirmei os `main` das duas classes de árvore:&#10;&#10;- `BinarySearchTree.main` insere na ordem: 37, 66, 42, 11, 72, 8, 17&#10;  - Resultado: essa ordem produz exatamente a árvore descrita quando as inserções seguem as regras da BST (menor à esquerda, maior à direita). Logo, `BinarySearchTree.main` está correto para esse layout.&#10;&#10;- `Tree.main` insere na ordem: 37, 11, 8, 17, 66, 42, 72&#10;  - Importante: `Tree` utiliza inserção por nível (preenche esquerda-&gt;direita usando uma fila). Com essa ordem o nó 66 não será filho direto da raiz — ele vai parar como filho do nó 11 (dependendo da sequência). Ou seja, `Tree` produz outra forma (estrutura por nível), não uma BST.&#10;&#10;Conclusão: se você quer aquela forma específica que respeita a propriedade BST, use `BinarySearchTree` (a `main` já insere em ordem correta). Se preferir que uma árvore genérica por nível tenha a mesma configuração, ajuste a ordem de inserção em `Tree.main` ou use o `BinarySearchTree` em sala.&#10;&#10;---&#10;&#10;## Refatorações e melhorias sugeridas (baixa complexidade de mudança)&#10;Pequenas melhorias que valem a pena e são ótimos exercícios para os estudantes:&#10;&#10;- Tornar as estruturas genéricas (usar generics: `LinkedList&lt;T&gt;`, `Stack&lt;T&gt;`, `Queue&lt;T&gt;`) para que suportem qualquer tipo, não só `int`/`String`.&#10;- BinarySearchTree.insert: renomear o parâmetro `root` do método recursivo para `node` para evitar confusão com o campo `root`. Outra opção: implementar versão iterativa para evitar overhead de recursão.&#10;- SupermarketArray.delete: agora o método espera índice 0-based internamente, mas o `Main` apresenta posições 1-based ao usuário e converte para 0-based antes de chamar `delete`. Para testes/integração você pode alterar o método para retornar `boolean` em vez de apenas imprimir erros, se preferir.&#10;- Adicionar testes unitários (JUnit) para cobrir casos de borda: listas vazias, remoção em listas com 1 elemento, remoção de nó com dois filhos em BST, etc.&#10;&#10;---&#10;&#10;## Complexidade — explicação rápida (Big-O) — para usar em aula&#10;- LinkedList (singly):&#10;  - append/prepend: O(1) (se temos ponteiro para tail para append)&#10;  - get(index): O(n)&#10;  - removeLast (se não há ponteiro para prev): O(n)&#10;- Stack (implementada com linked nodes):&#10;  - push/pop: O(1)&#10;  - acesso ao topo: O(1)&#10;- Queue (linked nodes):&#10;  - enqueue/dequeue: O(1)&#10;- BinarySearchTree (balanceada idealmente):&#10;  - search/insert/delete: O(log n) em média&#10;  - no pior caso (árvore degenerada): O(n)&#10;- Tree traversals (in/pre/post/BFS):&#10;  - todos os percursos visitam cada nó exatamente uma vez: O(n) tempo e O(h) espaço para recursão (h = altura)&#10;&#10;Dica pedagógica: enfatize diferença entre complexidade média e pior caso (BST depende da forma da árvore).&#10;&#10;---&#10;&#10;## Como usar — passos e exemplos&#10;Execute os `Main`s presentes nas pastas de exemplo, ou escreva pequenos runners/testes para experimentar as estruturas.&#10;&#10;### Exemplo rápido — executar `BinarySearchTree.main` compilado:&#10;&#10;```cmd&#10;mvn -DskipTests package&#10;java -cp target\classes dataStructure.BinarySearchTree&#10;```&#10;&#10;### Exemplo rápido — executar `array_supermarket`:&#10;&#10;```cmd&#10;mvn -DskipTests package&#10;java -cp target\classes array_supermarket.main.Main&#10;```&#10;&#10;---&#10;&#10;## Próximos passos sugeridos&#10;- Corrigir o `removeLast()` de `LinkedList` (pequena correção). Isso é um excelente exercício de revisão.&#10;- Converter as estruturas para `Generics` e adicionar testes JUnit rápidos.&#10;- Mover `FilaDeAtendimento` para um pacote (ex.: `app` ou `runner`) se quiser manter o projeto sem arquivos no pacote padrão.&#10;&#10;---&#10;&#10;## Contato&#10;Se quiser trocar ideias ou colaborar:&#10;&#10;- LinkedIn: https://www.linkedin.com/in/joannabraccini&#10;&#10;---&#10;&#10;(README atualizado em 2025-11-08)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>